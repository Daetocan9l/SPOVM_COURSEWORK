#include <iostream>
#include <windows.h>
#include <fileapi.h>
#include <string>
#include <vector>
#include <stdio.h>
#include <stdlib.h>
#include <WinNT.h>


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct bootsector {
    BYTE JumpBoot[3] = { 0xEB };
    BYTE FileSystemName[10] = "EXFAT   ";
    BYTE MustBeZero[53] = { NULL };
    LONG PartitionOffset[2] = { 0 };
    LONG VolumeLength[2] = { 7839657 };
    LONG FatOffset = 24;
    LONG FatLength = 512;
    LONG ClusterHeapOffset = 1048;
    LONG ClusterCount = 1024;
    LONG FirstClusterOfRootDirectory = 2;
    LONG VolumeSerialNumber = 2134;
    BYTE FileSystemRevision[2] = {1,5};//0x105
    BYTE VolumeFlags[2] = { 0 };
    BYTE BytesPerSectorShift = 9;
    BYTE SectorsPerClusterShift = 3;
    BYTE NumberOfFats = 1;
    BYTE DriveSelect = 0x80;
    BYTE PercentInUse = 0xFF;
    BYTE Reserved[7];
    BYTE BootCode[390] = {0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4};
    //BYTE BootSignature[2] = { 170,85 };//0xaa55
    //BYTE ReduntantSpace[512];
};

struct ex_bootsector {
    BYTE ExtendedBootCode[508] = {
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 };
    DWORD ExtendedBootSignature = 0xAA550000;
};

struct flash_parametres {
    BYTE ParametersGuid[16] = {0x0A,0x0C,0x7E,0x46,0x33,0x99,0x40,0x21,0x90,0xC8,0xFA,0x6D,0x38,0x9C,0x4B,0xA2 };
    DWORD EraseBlockSize = 4096;
    DWORD PageSize = 2048;
    DWORD SpareSectors = 1024;
    DWORD RandomAccessTime = 2000;
    DWORD ProgrammingTime = 2000;
    DWORD ReadCycle = 2000;
    DWORD WriteCycle = 2000;
    DWORD Reserved = {0};

};

struct null_parametres {
    BYTE ParametersGuid[16] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
    BYTE Reserved[32] = { 0 };
};

struct oem_parametres {
    flash_parametres f_params;
    null_parametres null_params[9];
    BYTE Reserved[32] = { 0 };
};

DWORD BootChecksum
        (
                BYTE* Sectors , // points to an in-memory copy of the 11 sectors
                USHORT BytesPerSector
        )
{
    DWORD NumberOfBytes = (DWORD)BytesPerSector * 11;
    DWORD Checksum = 0;
    DWORD Index;

    for (Index = 0; Index < NumberOfBytes; Index++)
    {
        if ((Index == 106) || (Index == 107) || (Index == 112))
        {
            continue;
        }
        Checksum = ((Checksum & 1) ? 0x80000000 : 0) + (Checksum >> 1) + (DWORD)Sectors[Index];
    }

    return Checksum;
}

struct fat {
    DWORD fat_entry[1026] = { 0xFFFFFFF8,0xFFFFFFFF };// заполнить 2-1025 индексы этими же числами
    BYTE ExcessSpace[258040];
};

struct cluster_heap {
 // записать 1024 раза по 512 байт
    BYTE Cluster[1024][512] = {0};
};

struct MainBootRegion {
    bootsector mainBootSector;
    ex_bootsector mainExBootSector;
    oem_parametres mainOEMParams;
    BYTE
    Reserved[512] = { 0 };
};

struct MainBootRegionSplitted {
    MainBootRegion mbr;
    BYTE array[sizeof(MainBootRegion)] = { 0 };
}mbrSplitted;

struct BackUpBootRegion {
    bootsector mainBootSector;
    ex_bootsector mainExBootSector;
    oem_parametres mainOEMParams;
    BYTE Reserved[512] = { 0 };
};

struct BackupBootRegionSplitted {
    BackUpBootRegion mbr;
    BYTE array[sizeof(BackUpBootRegion)] = {0};
} bbrSplitted;

struct VolumeStructure {
// main boot region
    MainBootRegion mbr;
    DWORD mainBootCheckSum = BootChecksum(mbrSplitted.array, 512);
// back up boot region
    BackUpBootRegion bbr;
    DWORD backupBootCheckSum = BootChecksum(bbrSplitted.array, 512);
    fat firstFAT;//необходимо заполнить одно поле перед записью
    fat secondFAT;//необходимо заполнить одно поле перед записью
    cluster_heap clusterHeap;
    BYTE ExcessSpace[7314321] = {0};
}exFAT_;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Класс, который содержит информацию о носителе
class CarrierInfo {
private:
    std::string m_name;
    std::string m_filesystem;
    int m_serialNumber;
public:
    CarrierInfo() {
        m_name = "";
        m_filesystem = "";
        m_serialNumber = 0;
    }
    CarrierInfo(std::string name, std::string filesystem, int serialNumber) {
        m_name = name;
        m_filesystem = filesystem;
        m_serialNumber = serialNumber;
    }
    CarrierInfo(const CarrierInfo &obj) {
        m_name = obj.m_name;
        m_filesystem = obj.m_filesystem;
        m_serialNumber = obj.m_serialNumber;
    }
    ~CarrierInfo() {}
    void set_name(std::string name){
        m_name = name;
    }
    void set_filesystem(std::string filesystem){
        m_filesystem = filesystem;
    }
    void set_serialNumber(int serialNumber){
        m_serialNumber = serialNumber;
    }
    void showCarrierInfo() {
        std::cout << "Name:" <<  m_name << std::endl;
        std::cout <<  "Filesystem:" << m_filesystem << std::endl;
        std::cout << "SerialNumber:" << m_serialNumber << std::endl;
    }
};

//Класс добавления носителей в вектор
class ScanСarriers {
private:
    std::vector<std::string> m_carriers;
public:
    ScanСarriers() {
        m_carriers.clear();
    }
    ScanСarriers(std::vector<std::string> carriers) {
        m_carriers = carriers;
    }
    ScanСarriers(const ScanСarriers &obj) {
        m_carriers = obj.m_carriers;
    }
    ~ScanСarriers() {}
   void add_carriers(){
       char disks[MAX_PATH];
       char *pNext = disks;
       GetLogicalDriveStringsA(sizeof(disks), disks);
       while(*pNext){
           if(GetDriveTypeA(pNext)==DRIVE_REMOVABLE) m_carriers.push_back((std::string)pNext);
           pNext+=strlen(pNext)+1;
       }
       parsingName();
   }
   std::vector<std::string> get_carriers(){
       return m_carriers;
   }
   void parsingName() {
       if(!m_carriers.empty()) {
            for(int i = 0; i < m_carriers.size(); i++) {
                m_carriers[i].erase(m_carriers[i].begin()+2,m_carriers[i].end());
            }
       }
   }
};

//Класс форматирования
class FormattingExFAT {
private:
    std::string m_drive;
public:
    FormattingExFAT() {
        m_drive = "";
    }
    FormattingExFAT(std::string drive) {
        m_drive = drive;
    }
    FormattingExFAT(const FormattingExFAT &obj) {
        m_drive = obj.m_drive;
    }
    ~FormattingExFAT() {}
    void set_device_name(std::string drive) {
        m_drive = drive;
    }
    void formatting() {
        puts("\n");
        std::string formattool = "format "+m_drive+" /fs:exfat /q";
        system(formattool.c_str());
    }
};

//Получение дескриптора флешки и запись структуры
void create_write_struct(std::string carrier) {
    HANDLE desc_carrier = CreateFileA(carrier.c_str(),GENERIC_WRITE,NULL,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
    LPDWORD countWriteFile;
    WriteFile(desc_carrier,&exFAT_,sizeof(exFAT_),countWriteFile,NULL);
}

//Функция проверки на ввод
int inputNumber(int min,int max) {
    int number;
    while(1){
        try {
            std::cin>>number;
            if(std::cin.fail())throw("Enter number:");
            if(number<min || number > max) throw("Try again:");
            else break;
        }
        catch(const char *ex) {
            std::cout<<ex;
            std::cin.clear();
            rewind(stdin);
        }
    }
    return number;
}

void showMenu() {
    puts("");
    puts("Choice an operation:");
    puts("1.Format media to file system exFAT");
    puts("2.Show media information");
    puts("0.Exit");
    std::cout<<"Enter number choice:";
}

void showManual(){
    std::cout<<std::endl;
    puts("Utility ALEXANDRIA intended for:");
    puts("1.Formatting the media file system in exFAT.");
    puts("2.Viewing brief information about the carrier");
    puts("Argument info designed to call a hint.");
    puts("Enjoy using ;)");
}

void choice1(FormattingExFAT tool,std::vector<std::string> carriers,int media){
    std::string carrier = carriers[media-1];
    create_write_struct(carrier);
    tool.set_device_name(carrier);
    tool.formatting();
}
void choice2(std::vector<std::string> carriers,int media){
    CarrierInfo carrierInfo;
    std::string carrier = carriers[media-1];
    char NameBuffer[MAX_PATH];
    char SysNameBuffer[MAX_PATH];
    DWORD VSNumber;
    DWORD MCLength;
    DWORD FileSF;
    if (GetVolumeInformation(carrier.c_str(),NameBuffer, sizeof(NameBuffer+1),
                             &VSNumber,&MCLength,&FileSF,SysNameBuffer,sizeof(SysNameBuffer)))
    {
        if(NameBuffer[0] == 0) {
            strcat(NameBuffer,"no name");
            carrierInfo.set_name(NameBuffer);
        }
        else carrierInfo.set_name(NameBuffer);
        carrierInfo.set_filesystem(SysNameBuffer);
        carrierInfo.set_serialNumber(VSNumber);
    }
    puts(carrier.c_str());
    carrierInfo.showCarrierInfo();
}

void checkArguments(int argc,char **argv){
    if(argc >2) {
        puts("'ALEXANDRIA info' - utility instruction");
        exit(0);
    }
    if(argc == 2) {
        if(strcmp(argv[1],"info")==0) {
            showManual();
        }
        else {
            puts("'ALEXANDRIA info' - utility instruction");
        }
        exit(0);
    }
}


int main(int argc,char **argv) {
    checkArguments(argc,argv);
    std::vector<std::string> carriersList;
    ScanСarriers scanCarriers;
    FormattingExFAT formattingtool;
    int choiceMedia = 0;
    int choiceMenu = 0;
    scanCarriers.add_carriers();
    carriersList = scanCarriers.get_carriers();
    if(carriersList.empty()) {
        puts("Media not connected");
        system("pause");
        exit(0);
    }
    while(1) {
        std::cout<<"Choice media:"<<std::endl;
        for(int i=0; i<carriersList.size();i++){
            std::cout<<i+1<<"."<<carriersList[i]<<std::endl;
        }
        std::cout<<"0.Exit."<<std::endl;
        std::cout<<"Media:";
        choiceMedia = inputNumber(0,carriersList.size());
        if(choiceMedia == 0) exit(0);
        showMenu();
        choiceMenu = inputNumber(0,2);
        switch(choiceMenu){
            case 1 : {
                choice1(formattingtool,carriersList,choiceMedia);
                system("pause");
                exit(0);
                break;
            }
            case 2 : {
                //system("cls");
                choice2(carriersList,choiceMedia);
                break;
            }
            default: {
                exit(0);
            }
        }
        system("pause");
    }
    return 0;
}
